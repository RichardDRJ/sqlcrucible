from __future__ import annotations
from importlib.machinery import ModuleSpec
from importlib.util import module_from_spec
from sqlalchemy.orm.attributes import Mapped
import sys
from sqlcrucible.entity.field_metadata import SQLAlchemyFieldDefinition
from sqlcrucible.entity.core import SQLAlchemyBase
from typing import Any


from typing import get_args, get_origin

import sqlalchemy.orm

from sqlcrucible.entity.core import SQLCrucibleEntity

from sqlcrucible.utils.types.transformer import (
    TypeTransformerChain,
    TypeTransformer,
    TypeTransformerResult,
)


class SQLCrucibleEntityToForwardRefTransformer(TypeTransformer):
    """Transforms SQLCrucibleEntity types to forward references.

    When an entity is used as a field type (e.g., in relationships), this
    transformer creates a forward reference to the entity's SQLAlchemy type
    to avoid circular dependencies.
    """

    def matches(self, annotation: Any) -> bool:
        return isinstance(annotation, type) and issubclass(annotation, SQLCrucibleEntity)

    def apply(
        self,
        annotation: type[SQLCrucibleEntity],
        chain: TypeTransformerChain,
    ) -> TypeTransformerResult:
        qualname = f"{annotation.__module__}.{annotation.__name__}"

        # When a fully-qualified name is imported, Python only creates the top level in the
        # current module's __dict__; everything else is bound inside its relevant module. So
        # in order to have a ForwardRef to `foo.bar.Baz`, we need to ensure that `foo.bar` is
        # loaded in sys.modules (which it inherently will be if `annotation` has been loaded
        # from it), and then bind just `foo` in our module.
        top_level = annotation.__module__.split(".")[0]
        return TypeTransformerResult(
            result=f"{qualname}.__sqlalchemy_type__",
            additional_globals={top_level: sys.modules[top_level]},
        )


field_transformer_chain = TypeTransformerChain(
    transformers=[
        SQLCrucibleEntityToForwardRefTransformer(),
        *TypeTransformerChain.DEFAULT_TRANSFORMERS,
    ]
)


def _public_fields(it: dict[str, Any]) -> dict[str, Any]:
    if "__all__" in it:
        names = it["__all__"]
    else:
        names = [name for name in it if not name.startswith("_")]
    return {name: it[name] for name in names}


def _transform_tp(source: type[SQLCrucibleEntity]) -> type[Any]:
    params = vars(source).get("__sqlalchemy_params__", {})
    base = _get_sa_base(source)

    # If a given field _already_ exists in the inner model's base, don't recreate it
    # base_mapper = inspect(cast(Inspectable[Mapper[Any]], base), raiseerr=False)
    # base_attrs = base_mapper.attrs if base_mapper is not None else {}
    field_defs = source.__sqlalchemy_field_definitions__().values()
    field_transform_results = {
        field_def.mapped_name: _transform_field_type(source, field_def) for field_def in field_defs
    }
    field_defaults = {
        field_def.mapped_name: default
        for field_def in field_defs
        if (default := field_def.mapped_attr) is not None
    }

    annotations = {key: it.result for key, it in field_transform_results.items()}
    additional_globals = {
        key: value
        for it in field_transform_results.values()
        for key, value in it.additional_globals.items()
    }

    namespace = {
        **field_defaults,
        **params,
        "__annotations__": annotations,
    }

    # Use predictable module path for stub generation
    automodel_name = f"{source.__name__}AutoModel"
    target_module_name = f"sqlcrucible.generated.{source.__module__}"

    result = type(automodel_name, (base,), namespace)

    source_module = sys.modules[source.__module__]

    # Create or reuse the generated module
    if target_module_name in sys.modules:
        target_module = sys.modules[target_module_name]
    else:
        target_module = module_from_spec(ModuleSpec(target_module_name, loader=None))
        sys.modules[target_module_name] = target_module

    # We include the source's globals/locals in our autogenerated module so that defining a ForwardRef
    # `mapped_tp` correctly picks up the type.
    target_module.__dict__.update(_public_fields(source_module.__dict__))
    target_module.__dict__.update(source.__dict__)

    target_module.__dict__.update(additional_globals)
    target_module.__dict__[automodel_name] = result
    result.__module__ = target_module_name

    return result


def _get_sa_base(annotation: type[SQLCrucibleEntity]) -> type[Any]:
    if explicit_base := vars(annotation).get("__sqlalchemy_base__"):
        return explicit_base
    return next(
        (
            it.__sqlalchemy_type__
            for it in annotation.__mro__[1:]
            if issubclass(it, SQLCrucibleEntity)
        ),
        SQLAlchemyBase,
    )


def _transform_field_type(
    owner: type[SQLCrucibleEntity],
    field_def: SQLAlchemyFieldDefinition,
) -> TypeTransformerResult:
    match (get_origin(field_def.source_tp), get_args(field_def.source_tp)):
        case (sqlalchemy.orm.Mapped, _):
            return TypeTransformerResult(result=field_def.source_tp)
        case _:
            inner = field_transformer_chain.apply(field_def.source_tp)
            return TypeTransformerResult(
                result=Mapped[inner.result],
                additional_globals=inner.additional_globals,
            )


class AutoSQLAlchemyModelFactory:
    def __init__(self):
        self._cache: dict[type[SQLCrucibleEntity], type[Any]] = {}

    def __call__(self, source: type[SQLCrucibleEntity]) -> type[Any]:
        """Generate or retrieve cached SQLAlchemy model for an entity class.

        Args:
            source: The SQLCrucibleEntity subclass to generate a model for.

        Returns:
            The generated SQLAlchemy model class.
        """
        if source not in self._cache:
            self._cache[source] = _transform_tp(source)

        return self._cache[source]


auto_sqlalchemy_model_factory = AutoSQLAlchemyModelFactory()
