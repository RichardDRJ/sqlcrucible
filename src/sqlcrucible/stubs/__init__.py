"""Stub generator for SQLCrucible entities.

Generates type stubs that provide type checker support for SAType[Entity] access.
"""

from __future__ import annotations
from functools import reduce
from sqlcrucible.utils.sa_fields import sa_field_type
from sqlalchemy import inspect

import importlib
import types
import typing
from dataclasses import dataclass
from pathlib import Path
from typing import Any, get_args, get_origin, Iterable, TypeVar, Callable

from sqlalchemy.orm import Mapped
from typing_extensions import get_annotations

from sqlcrucible.entity.core import SQLCrucibleEntity


@dataclass
class TypeDef:
    """Represents a type definition with its required imports."""

    imports: list[str]
    type_def: str


@dataclass
class ClassDef:
    """Represents a class definition with its required imports."""

    source: type[Any]
    module: str
    imports: list[str]
    class_def: str


def get_entities_from_module(module_path: str) -> list[type[SQLCrucibleEntity]]:
    """Import a module and find all SQLCrucibleEntity subclasses.

    Args:
        module_path: Dotted module path (e.g., 'myapp.models')

    Returns:
        List of entity classes found in the module (excluding abstract entities).
    """
    module = importlib.import_module(module_path)
    entities = []

    for name in dir(module):
        obj = getattr(module, name)
        if (
            isinstance(obj, type)
            and issubclass(obj, SQLCrucibleEntity)
            and obj is not SQLCrucibleEntity
            and obj.__module__ == module_path
        ):
            # Skip abstract entities
            params = getattr(obj, "__sqlalchemy_params__", {})
            if params.get("__abstract__"):
                continue
            entities.append(obj)

    return entities


def is_autogenerated(cls: type[Any]) -> bool:
    """Check if a class is an autogenerated SQLAlchemy model from SQLCrucible."""
    return cls.__module__.startswith("sqlcrucible.generated.")


def sort_sa_types(sa_types: list[type]) -> list[type]:
    """Sort entities so that base classes come before derived classes.

    This ensures that when generating stubs, parent classes are defined
    before their children.
    """
    return list(
        dict.fromkeys(
            (tp for sa_type in sa_types for tp in sa_type.__mro__[::-1] if is_autogenerated(tp))
        )
    )


def fqn(tp: type[Any]) -> str:
    """Get the fully qualified name for a type."""
    module = tp.__module__
    name = tp.__name__
    if module in ("builtins",):
        return name
    return f"{module}.{name}"


def to_typedef(ann: Any) -> TypeDef:
    """Convert a type annotation to a TypeDef with imports.

    Args:
        entity: The entity class (for context in error messages).
        ann: The type annotation to convert.

    Returns:
        TypeDef with the string representation and required imports.
    """
    # Handle string annotations (forward references)
    if isinstance(ann, str):
        return TypeDef(imports=[], type_def=f'"{ann}"')

    # Handle None
    if ann is None or ann is type(None):
        return TypeDef(imports=[], type_def="None")

    origin = get_origin(ann)
    args = get_args(ann)

    match origin, args:
        case typing.Annotated, (tp, *_):
            return to_typedef(tp)
        case _ if origin is Mapped:
            return to_typedef((args or [Any])[0])
        case (types.UnionType, _) | (typing.Union, _):
            args_typedefs = [to_typedef(arg) for arg in args]
            all_imports = ["typing", *[imp for td in args_typedefs for imp in td.imports]]
            args_str = ", ".join(td.type_def for td in args_typedefs)
            return TypeDef(imports=all_imports, type_def=f"typing.Union[{args_str}]")
        case None, _:
            if isinstance(ann, type):
                if ann.__module__ == "builtins":
                    return TypeDef(imports=[], type_def=ann.__name__)
                return TypeDef(imports=[ann.__module__], type_def=fqn(ann))
            return TypeDef(imports=["typing"], type_def="typing.Any")

    # Generic type with origin and args
    origin_typedef = to_typedef(origin)
    args_typedefs = [to_typedef(arg) for arg in args]

    all_imports = [imp for td in (origin_typedef, *args_typedefs) for imp in td.imports]
    args_str = ", ".join(td.type_def for td in args_typedefs)

    # Use the origin's type_def (which is the short name)
    type_def = f"{origin_typedef.type_def}[{args_str}]"

    return TypeDef(imports=all_imports, type_def=type_def)


def construct_model_def(sqlalchemy_type: type) -> ClassDef:
    """Construct a stub class definition for an entity's SQLAlchemy model.

    This generates the "AutoModel" class that represents the SQLAlchemy type
    with InstrumentedAttribute fields for type checking.

    Args:
        entity: The SQLCrucibleEntity to generate a model stub for.
        all_entities: Set of all entities being processed (for inheritance).

    Returns:
        ClassDef with the class definition and required imports.
    """
    if mapper := inspect(sqlalchemy_type, raiseerr=False):
        field_names = list(mapper.attrs.keys())
    else:
        field_names = list(get_annotations(sqlalchemy_type))

    typedefs = {
        field_name: to_typedef(sa_field_type(sqlalchemy_type, field_name))
        for field_name in field_names
    }

    base_imports = [
        base.__module__
        for base in sqlalchemy_type.__bases__
        if base.__module__ != sqlalchemy_type.__module__
    ]
    imports = list(
        dict.fromkeys(
            [
                "sqlalchemy.orm.attributes",
                *base_imports,
                *(it for typedef in typedefs.values() for it in typedef.imports),
            ]
        )
    )
    field_lines = [
        f"    {name}: sqlalchemy.orm.attributes.InstrumentedAttribute[{typedef.type_def}]"
        for name, typedef in typedefs.items()
    ]

    bases = [
        fqn(base) if base.__module__ != sqlalchemy_type.__module__ else base.__name__
        for base in sqlalchemy_type.__bases__
    ]
    class_header = f"class {sqlalchemy_type.__name__}({', '.join(bases)}):"

    if field_lines:
        body = "\n".join(field_lines)
    else:
        body = "    pass"

    class_def = f"{class_header}\n{body}"

    return ClassDef(
        source=sqlalchemy_type,
        module=sqlalchemy_type.__module__,
        imports=imports,
        class_def=class_def,
    )


def construct_entity_stub_def(entity: type[SQLCrucibleEntity]) -> ClassDef:
    """Construct a stub class definition for a SQLCrucibleEntity.

    This generates the stub for the entity class that declares the
    __sqlalchemy_type__ ClassVar pointing to the AutoModel.

    Args:
        entity: The SQLCrucibleEntity to generate a stub for.
        generated_module: The module path where AutoModels are defined.

    Returns:
        ClassDef with the class definition and required imports.
    """
    imports = [
        "typing",
        entity.__sqlalchemy_type__.__module__,
    ]

    class_def = f"""class {entity.__name__}:
    __sqlalchemy_automodel__: typing.ClassVar[type[{fqn(entity.__sqlalchemy_type__)}]]
    __sqlalchemy_type__: typing.ClassVar[type[{fqn(entity.__sqlalchemy_type__)}]]"""

    return ClassDef(
        source=entity,
        module=entity.__module__,
        imports=imports,
        class_def=class_def,
    )


def _build_import_block(imports: list[str], current_module: str) -> str:
    """Build an import block from a list of FQN imports.

    Args:
        imports: List of fully qualified names to import.
        current_module: The module we're generating (to filter self-imports).

    Returns:
        String containing the import statements.
    """
    # Deduplicate while preserving order
    imports = list(dict.fromkeys(imports))

    # Filter out self-imports
    imports = [imp for imp in imports if not imp.startswith(f"{current_module}.")]

    return "\n".join(f"import {imp}" for imp in sorted(imports))


def _generate_model_defs_for_entity(entity: type[SQLCrucibleEntity]) -> list[ClassDef]:
    return [
        *(
            construct_model_def(it)
            for it in entity.__sqlalchemy_type__.__mro__[::-1]
            if is_autogenerated(it)
        ),
        construct_entity_stub_def(entity),
    ]


def _stub_path(root: Path, module_name: str) -> Path:
    module_parts = module_name.split(".")
    return root.joinpath(
        *module_parts[:-1],
        f"{module_parts[-1]}.pyi",
    )


def _write_to_stub_file(classdefs: list[ClassDef], stubs_root: Path, module_name: str):
    imports = [it for classdef in classdefs for it in classdef.imports]

    import_block = _build_import_block(imports, module_name)
    class_block = "\n\n".join(it.class_def for it in classdefs)

    stub_path = _stub_path(stubs_root, module_name)
    stub_path.parent.mkdir(parents=True, exist_ok=True)

    # Create __init__.pyi files in all parent directories
    # so type checkers recognize them as packages
    current = stubs_root
    for part in module_name.split(".")[:-1]:
        current = current / part
        init_file = current / "__init__.pyi"
        if not init_file.exists():
            init_file.touch()

    with open(stub_path, "w") as fd:
        fd.write(import_block)
        fd.write("\n\n")
        fd.write(class_block)


_T = TypeVar("_T")


def _unique_by(iterable: Iterable[_T], key: Callable[[_T], Any]) -> Iterable[_T]:
    seen = set()
    for entry in iterable:
        identifier = key(entry)
        if identifier not in seen:
            seen.add(identifier)
            yield entry


_K = TypeVar("_K")


def _group_by(iterable: Iterable[_T], key: Callable[[_T], _K]) -> dict[_K, list[_T]]:
    return reduce(
        lambda acc, it: {**acc, key(it): [*acc.get(key(it), []), it]},
        iterable,
        {},
    )


def generate_stubs_for_module(
    module_path: str,
    output_dir: Path,
):
    """Generate both stub files for a module.

    Args:
        module_path: Dotted module path (e.g., 'myapp.models')
        output_dir: Root output directory for stubs.

    Returns:
        Tuple of (entity_stub_path, model_stub_path).
    """
    entities = get_entities_from_module(module_path)
    if not entities:
        raise ValueError(f"No SQLCrucibleEntity subclasses found in {module_path}")

    all_classdefs = [
        classdef for entity in entities for classdef in _generate_model_defs_for_entity(entity)
    ]
    classdefs_by_module = _group_by(all_classdefs, lambda it: it.module)
    for module, classdefs in classdefs_by_module.items():
        classdefs = list(_unique_by(classdefs, lambda it: it.source))
        _write_to_stub_file(classdefs, output_dir, module)


def generate_stubs(
    module_paths: list[str],
    output_dir: str = "stubs",
):
    """Generate stubs for multiple modules.

    Args:
        module_paths: List of dotted module paths.
        output_dir: Root output directory for stubs.

    Returns:
        Dict mapping module path to (entity_stub_path, model_stub_path).
    """
    output_path = Path(output_dir)

    for module_path in module_paths:
        generate_stubs_for_module(module_path, output_path)
