"""Stub class definition generation."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any

from sqlalchemy import inspect
from typing_extensions import get_annotations

from sqlcrucible.entity.core import SQLCrucibleEntity
from sqlcrucible.entity.field_resolution import resolve_sa_field_type
from sqlcrucible.stubs.discovery import is_autogenerated
from sqlcrucible.stubs.serialization import fqn, to_typedef


@dataclass(slots=True)
class ClassDef:
    """Represents a class definition with its required imports."""

    source: type[Any]
    module: str
    imports: list[str]
    class_def: str


def sa_field_type(tp: type, field_name: str) -> Any:
    """Determine the Python type of a SQLAlchemy model field."""
    resolved = resolve_sa_field_type(tp, field_name)
    if resolved is not None:
        return resolved
    raise TypeError(
        f"Could not determine type of SQLAlchemy field {field_name} in SQLAlchemy type {tp}"
    )


def construct_model_def(sqlalchemy_type: type) -> ClassDef:
    """Construct a stub class definition for an entity's SQLAlchemy model.

    This generates the "AutoModel" class that represents the SQLAlchemy type
    with InstrumentedAttribute fields for type checking.
    """
    if mapper := inspect(sqlalchemy_type, raiseerr=False):
        field_names = list(mapper.attrs.keys())
    else:
        field_names = list(get_annotations(sqlalchemy_type))

    typedefs = {
        field_name: to_typedef(sa_field_type(sqlalchemy_type, field_name))
        for field_name in field_names
    }

    base_imports = [
        base.__module__
        for base in sqlalchemy_type.__bases__
        if base.__module__ != sqlalchemy_type.__module__
    ]
    imports = list(
        dict.fromkeys(
            [
                "sqlalchemy.orm.attributes",
                *base_imports,
                *(it for typedef in typedefs.values() for it in typedef.imports),
            ]
        )
    )
    field_lines = [
        f"    {name}: sqlalchemy.orm.attributes.InstrumentedAttribute[{typedef.type_def}]"
        for name, typedef in typedefs.items()
    ]

    bases = [
        fqn(base) if base.__module__ != sqlalchemy_type.__module__ else base.__name__
        for base in sqlalchemy_type.__bases__
    ]
    class_header = f"class {sqlalchemy_type.__name__}({', '.join(bases)}):"

    if field_lines:
        body = "\n".join(field_lines)
    else:
        body = "    pass"

    class_def = f"{class_header}\n{body}"

    return ClassDef(
        source=sqlalchemy_type,
        module=sqlalchemy_type.__module__,
        imports=imports,
        class_def=class_def,
    )


def specificity_order(entities: list[type[SQLCrucibleEntity]]) -> list[type[SQLCrucibleEntity]]:
    """Sort entities so subclasses appear before parent classes.

    Type checkers match the first applicable overload, so more-specific
    types (subclasses) must be listed before less-specific ones (parents).

    This is achieved by:
    1. Flattening all entities' SQLCrucibleEntity MRO entries in reverse order (ancestors before descendants);
    2. Taking the first instance of each class w/ dict.fromkeys (so each ancestor is defined before any of its descendents);
    3. Reversing the result (so each descendent is defined before any of its ancestors).
    """
    return list(
        reversed(
            dict.fromkeys(
                it
                for entity in entities
                for it in reversed(entity.__mro__)
                if isinstance(it, type)
                and issubclass(it, SQLCrucibleEntity)
                and it is not SQLCrucibleEntity
            )
        )
    )


def construct_sa_type_stub(entities: list[type[SQLCrucibleEntity]]) -> str:
    """Construct a stub for SAType with @overload declarations.

    Generates overloads on SATypeMeta.__getitem__ that map each entity
    to its auto-generated SQLAlchemy model type, enabling type checkers
    to resolve SAType[Entity] to the concrete automodel.
    """
    imports: set[str] = set()
    overloads: list[str] = []
    for entity in specificity_order(entities):
        sa_type = entity.__sqlalchemy_type__
        imports.add(entity.__module__)
        imports.add(sa_type.__module__)
        overloads.append(
            f"    @typing.overload\n"
            f"    def __getitem__(cls, item: type[{fqn(entity)}]) -> type[{fqn(sa_type)}]: ..."
        )

    import_block = "\n".join(f"import {imp}" for imp in sorted({"typing", *imports}))

    overload_block = "\n".join(overloads)

    return (
        f"{import_block}\n\n"
        f"class SATypeMeta(type):\n"
        f"{overload_block}\n"
        f"    @typing.overload\n"
        f"    def __getitem__(cls, item: type) -> type: ...\n\n"
        f"class SAType(metaclass=SATypeMeta): ...\n"
    )


def build_import_block(imports: list[str], current_module: str) -> str:
    """Build an import block from a list of FQN imports."""
    imports = list(dict.fromkeys(imports))
    imports = [imp for imp in imports if not imp.startswith(f"{current_module}.")]
    return "\n".join(f"import {imp}" for imp in sorted(imports))


def generate_model_defs_for_entity(entity: type[SQLCrucibleEntity]) -> list[ClassDef]:
    """Generate stub class definitions for an entity's auto-generated SQLAlchemy models.

    Only generates stubs for auto-generated models (under sqlcrucible.generated.*),
    not for the entity class itself. Entity stub files would shadow the real source
    and break type checkers that treat .pyi files as full class replacements.
    """
    return [
        construct_model_def(it)
        for it in entity.__sqlalchemy_type__.__mro__[::-1]
        if is_autogenerated(it)
    ]
