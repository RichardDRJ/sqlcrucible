"""Stub class definition generation."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, cast

from sqlalchemy import inspect
from sqlalchemy.orm import (
    ColumnProperty,
    CompositeProperty,
    Mapper,
    RelationshipProperty,
)
from typing_extensions import Format, get_annotations

from sqlcrucible._types.forward_refs import evaluate_forward_refs
from sqlcrucible.entity.core import SQLCrucibleEntity
from sqlcrucible.stubs.discovery import is_autogenerated
from sqlcrucible.stubs.serialization import fqn, to_typedef


@dataclass(slots=True)
class ClassDef:
    """Represents a class definition with its required imports."""

    source: type[Any]
    module: str
    imports: list[str]
    class_def: str


def sa_field_type(tp: type, field_name: str) -> Any:
    """Determine the Python type of a SQLAlchemy model field."""
    annotations = get_annotations(tp, eval_str=True, format=Format.VALUE)
    if (annotation := annotations.get(field_name)) is not None:
        return evaluate_forward_refs(annotation, owner=tp)

    mapper = cast(Mapper[Any], inspect(tp))
    attrs = mapper.attrs
    prop = attrs.get(field_name)
    match prop:
        case ColumnProperty():
            return prop.columns[0].type.python_type
        case RelationshipProperty():
            return prop.entity.class_
        case CompositeProperty():
            return prop.composite_class
        case _:
            raise TypeError(
                f"Could not determine type of SQLAlchemy field {field_name} in SQLAlchemy type {tp}"
            )


def construct_model_def(sqlalchemy_type: type) -> ClassDef:
    """Construct a stub class definition for an entity's SQLAlchemy model.

    This generates the "AutoModel" class that represents the SQLAlchemy type
    with InstrumentedAttribute fields for type checking.
    """
    if mapper := inspect(sqlalchemy_type, raiseerr=False):
        field_names = list(mapper.attrs.keys())
    else:
        field_names = list(get_annotations(sqlalchemy_type))

    typedefs = {
        field_name: to_typedef(sa_field_type(sqlalchemy_type, field_name))
        for field_name in field_names
    }

    base_imports = [
        base.__module__
        for base in sqlalchemy_type.__bases__
        if base.__module__ != sqlalchemy_type.__module__
    ]
    imports = list(
        dict.fromkeys(
            [
                "sqlalchemy.orm.attributes",
                *base_imports,
                *(it for typedef in typedefs.values() for it in typedef.imports),
            ]
        )
    )
    field_lines = [
        f"    {name}: sqlalchemy.orm.attributes.InstrumentedAttribute[{typedef.type_def}]"
        for name, typedef in typedefs.items()
    ]

    bases = [
        fqn(base) if base.__module__ != sqlalchemy_type.__module__ else base.__name__
        for base in sqlalchemy_type.__bases__
    ]
    class_header = f"class {sqlalchemy_type.__name__}({', '.join(bases)}):"

    if field_lines:
        body = "\n".join(field_lines)
    else:
        body = "    pass"

    class_def = f"{class_header}\n{body}"

    return ClassDef(
        source=sqlalchemy_type,
        module=sqlalchemy_type.__module__,
        imports=imports,
        class_def=class_def,
    )


def construct_entity_stub_def(entity: type[SQLCrucibleEntity]) -> ClassDef:
    """Construct a stub class definition for a SQLCrucibleEntity.

    This generates the stub for the entity class that declares the
    __sqlalchemy_type__ ClassVar pointing to the AutoModel.
    """
    imports = [
        "typing",
        entity.__sqlalchemy_type__.__module__,
    ]

    class_def = f"""class {entity.__name__}:
    __sqlalchemy_automodel__: typing.ClassVar[type[{fqn(entity.__sqlalchemy_type__)}]]
    __sqlalchemy_type__: typing.ClassVar[type[{fqn(entity.__sqlalchemy_type__)}]]"""

    return ClassDef(
        source=entity,
        module=entity.__module__,
        imports=imports,
        class_def=class_def,
    )


def build_import_block(imports: list[str], current_module: str) -> str:
    """Build an import block from a list of FQN imports."""
    imports = list(dict.fromkeys(imports))
    imports = [imp for imp in imports if not imp.startswith(f"{current_module}.")]
    return "\n".join(f"import {imp}" for imp in sorted(imports))


def generate_model_defs_for_entity(entity: type[SQLCrucibleEntity]) -> list[ClassDef]:
    """Generate all stub class definitions for an entity (AutoModel + entity stub)."""
    return [
        *(
            construct_model_def(it)
            for it in entity.__sqlalchemy_type__.__mro__[::-1]
            if is_autogenerated(it)
        ),
        construct_entity_stub_def(entity),
    ]
