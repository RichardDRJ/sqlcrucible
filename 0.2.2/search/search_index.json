{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SQLCrucible","text":"<p>Get the full power of Pydantic for your API and the full power of SQLAlchemy for your database, without compromising on either.</p> <p>SQLCrucible is a compatibility layer that lets you define a single model class that works as both a Pydantic model and a SQLAlchemy table, with explicit conversion between the two.</p>"},{"location":"#why-sqlcrucible","title":"Why SQLCrucible?","text":"<p>In a FastAPI/SQLAlchemy web application, you typically need two sets of models:</p> <ul> <li>Pydantic models for API serialization, validation, and documentation</li> <li>SQLAlchemy models for database persistence and queries</li> </ul> <p>These models often mirror each other field-for-field, leading to:</p> <ul> <li>Duplication \u2014 the same fields defined twice, in two places</li> <li>Drift \u2014 models get out of sync as the codebase evolves</li> <li>Boilerplate \u2014 manual conversion code for every database operation</li> </ul> <p>With SQLCrucible, you define your model once:</p> <pre><code>from typing import Annotated\nfrom uuid import UUID, uuid4\nfrom pydantic import Field\nfrom sqlalchemy.orm import mapped_column\nfrom sqlcrucible import SQLCrucibleBaseModel\n\nclass Artist(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__tablename__\": \"artist\"}\n\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    name: Annotated[str, mapped_column()]\n</code></pre> <p>You get:</p> <ul> <li>A Pydantic model that works with FastAPI, serialization, and validation</li> <li>A SQLAlchemy table with proper column types and constraints</li> <li>Type-safe conversion methods between the two</li> </ul>"},{"location":"#design-principles","title":"Design Principles","text":""},{"location":"#explicit-is-better-than-implicit","title":"Explicit is better than implicit","text":"<p>Conversion between Pydantic and SQLAlchemy models only happens when you ask for it \u2014 by calling <code>to_sa_model()</code> or <code>from_sa_model()</code>. By keeping conversion explicit, SQLCrucible ensures your Pydantic models remain \"pure\" Pydantic (working seamlessly with FastAPI, standard serialization, and any other Pydantic-compatible tooling) and your SQLAlchemy models remain \"pure\" SQLAlchemy (supporting anything SQLAlchemy supports, and working seamlessly with SQLAlchemy tooling like Alembic).</p>"},{"location":"#dont-reinvent-sqlalchemy","title":"Don't reinvent SQLAlchemy","text":"<p>SQLCrucible uses native SQLAlchemy constructs directly. You define columns with <code>mapped_column()</code>, relationships with <code>relationship()</code>, and inheritance with <code>__mapper_args__</code> \u2014 exactly as you would in plain SQLAlchemy. If SQLAlchemy supports it, you can use it immediately.</p>"},{"location":"#everything-has-an-escape-hatch","title":"Everything has an escape hatch","text":"<p>SQLCrucible is designed to get out of your way:</p> <ul> <li>Mix SQLCrucible entities with standard SQLAlchemy models in the same database</li> <li>Use only the parts you need \u2014 you can even attach entities to existing SQLAlchemy models</li> <li>Customize the generated SQLAlchemy model with hybrid properties, custom methods, etc.</li> <li>Drop down to raw SQLAlchemy queries whenever needed</li> </ul>"},{"location":"#when-to-use-sqlcrucible","title":"When to Use SQLCrucible","text":"<p>SQLCrucible is a good fit when:</p> <ul> <li>You're building an API (FastAPI, Litestar, etc.) backed by a SQL database</li> <li>Your API models and database models are structurally similar</li> <li>You want SQLAlchemy's full feature set (inheritance, relationships, hybrid properties) without abstraction layers</li> </ul> <p>SQLCrucible may not be the best fit when:</p> <ul> <li>Your API models and database models are fundamentally different shapes</li> <li>You need to support multiple database backends with different schemas</li> <li>You prefer a more opinionated/implicit approach</li> </ul>"},{"location":"comparison/","title":"Comparison with SQLModel","text":"<p>SQLModel is a popular library that also bridges Pydantic and SQLAlchemy. This page compares the two approaches to help you choose the right tool for your project.</p>"},{"location":"comparison/#philosophy","title":"Philosophy","text":""},{"location":"comparison/#sqlcrucibles-approach","title":"SQLCrucible's Approach","text":"<ul> <li>Explicit conversion between Pydantic and SQLAlchemy models via <code>to_sa_model()</code> and <code>from_sa_model()</code></li> <li>Native SQLAlchemy constructs \u2014 uses <code>mapped_column()</code>, <code>relationship()</code>, <code>__mapper_args__</code> directly</li> <li>Pure Pydantic models that work with any Pydantic tooling</li> <li>Full SQLAlchemy feature support without waiting for library updates</li> </ul>"},{"location":"comparison/#sqlmodels-approach","title":"SQLModel's Approach","text":"<ul> <li>Single class serves both purposes (less boilerplate for simple cases)</li> <li>Custom field types and abstractions over SQLAlchemy</li> <li>Tighter integration means less explicit conversion code</li> <li>More opinionated design choices</li> </ul>"},{"location":"comparison/#feature-comparison","title":"Feature Comparison","text":"Feature SQLCrucible SQLModel Single class definition Yes Yes Pure Pydantic models Yes No (hybrid) Pure SQLAlchemy models Yes No (hybrid) Native <code>mapped_column()</code> Yes No Native <code>relationship()</code> Yes Limited All inheritance patterns Yes Limited Custom type converters Yes Limited Alembic compatibility Full Full FastAPI integration Full Built-in"},{"location":"comparison/#code-comparison","title":"Code Comparison","text":""},{"location":"comparison/#basic-model","title":"Basic Model","text":"SQLCrucibleSQLModel <pre><code>from typing import Annotated\nfrom uuid import UUID, uuid4\nfrom pydantic import Field\nfrom sqlalchemy.orm import mapped_column\nfrom sqlcrucible import SQLCrucibleBaseModel\n\nclass User(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__tablename__\": \"user\"}\n\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    name: str\n    email: str\n</code></pre> <pre><code>from uuid import UUID, uuid4\nfrom sqlmodel import SQLModel, Field\n\nclass User(SQLModel, table=True):\n    id: UUID = Field(default_factory=uuid4, primary_key=True)\n    name: str\n    email: str\n</code></pre>"},{"location":"comparison/#database-operations","title":"Database Operations","text":"SQLCrucibleSQLModel <pre><code># Create\nuser = User(name=\"Alice\", email=\"alice@example.com\")\nsession.add(user.to_sa_model())\nsession.commit()\n\n# Query\nsa_user = session.scalar(select(SAType[User]).where(SAType[User].name == \"Alice\"))\nuser = User.from_sa_model(sa_user)\n</code></pre> <pre><code># Create\nuser = User(name=\"Alice\", email=\"alice@example.com\")\nsession.add(user)\nsession.commit()\n\n# Query\nuser = session.exec(select(User).where(User.name == \"Alice\")).first()\n</code></pre>"},{"location":"comparison/#relationships","title":"Relationships","text":"SQLCrucibleSQLModel <pre><code>from sqlalchemy.orm import relationship\nfrom sqlcrucible.entity.fields import readonly_field\nfrom sqlcrucible.entity.annotations import SQLAlchemyField\n\nclass Author(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__tablename__\": \"author\"}\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    name: str\n\n    books = readonly_field(\n        list[\"Book\"],\n        SQLAlchemyField(\n            name=\"books\",\n            attr=relationship(lambda: Book.__sqlalchemy_type__),\n        ),\n    )\n</code></pre> <pre><code>from sqlmodel import Relationship\n\nclass Author(SQLModel, table=True):\n    id: UUID = Field(default_factory=uuid4, primary_key=True)\n    name: str\n\n    books: list[\"Book\"] = Relationship(back_populates=\"author\")\n</code></pre>"},{"location":"comparison/#when-to-choose-sqlcrucible","title":"When to Choose SQLCrucible","text":"<p>Choose SQLCrucible if you:</p> <ul> <li>Want full SQLAlchemy feature support (all inheritance patterns, hybrid properties, etc.)</li> <li>Need pure Pydantic models that work with all Pydantic tooling</li> <li>Prefer explicit over implicit conversion</li> <li>Have complex models that benefit from SQLAlchemy's full power</li> <li>Want to use native SQLAlchemy constructs without abstractions</li> </ul>"},{"location":"comparison/#when-to-choose-sqlmodel","title":"When to Choose SQLModel","text":"<p>Choose SQLModel if you:</p> <ul> <li>Have simple models without complex inheritance or relationships</li> <li>Prefer less boilerplate over explicit control</li> <li>Want tighter FastAPI integration out of the box</li> <li>Are comfortable with the hybrid model approach</li> <li>Don't need advanced SQLAlchemy features</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install SQLCrucible with pip:</p> <pre><code>pip install sqlcrucible\n</code></pre> <p>Or with uv:</p> <pre><code>uv add sqlcrucible\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":"<p>Here's a complete example showing the typical workflow:</p> <pre><code>from typing import Annotated\nfrom uuid import UUID, uuid4\n\nfrom pydantic import Field\nfrom sqlalchemy import create_engine, select\nfrom sqlalchemy.orm import Session, mapped_column\n\nfrom sqlcrucible import SAType, SQLCrucibleBaseModel\n\n# 1. Define your entity\nclass Artist(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__tablename__\": \"artist\"}\n\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    name: str\n\n# 2. Create the database tables\nengine = create_engine(\"sqlite:///:memory:\")\nSAType[Artist].__table__.metadata.create_all(engine)\n\n# 3. Create an entity and save it\nartist = Artist(name=\"Bob Dylan\")\nwith Session(engine) as session:\n    session.add(artist.to_sa_model())  # Convert to SQLAlchemy model\n    session.commit()\n\n# 4. Query and convert back\nwith Session(engine) as session:\n    sa_artist = session.scalar(\n        select(SAType[Artist]).where(SAType[Artist].name == \"Bob Dylan\")\n    )\n    artist = Artist.from_sa_model(sa_artist)  # Convert back to entity\n    print(artist.name)  # \"Bob Dylan\"\n</code></pre> <p>The <code>Artist</code> class is a standard Pydantic model \u2014 it works with FastAPI, has validation, and serializes to JSON. When you need to interact with the database, you explicitly convert to and from the SQLAlchemy model.</p>"},{"location":"getting-started/#what-this-replaces","title":"What This Replaces","text":"<p>Without SQLCrucible, you'd need to write equivalent code like this:</p> <pre><code>from uuid import UUID, uuid4\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy.orm import mapped_column, DeclarativeBase, Mapped\nfrom typing import Any, Self\n\nclass Base(DeclarativeBase): ...\n\nclass ArtistSQLAlchemyModel(Base):\n    __tablename__ = \"artist\"\n    id: Mapped[UUID] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\nclass Artist(BaseModel):\n    __sqlalchemy_type__: type[Any] = ArtistSQLAlchemyModel\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n\n    def to_sa_model(self) -&gt; ArtistSQLAlchemyModel:\n        return ArtistSQLAlchemyModel(\n            id=self.id,\n            name=self.name\n        )\n\n    @classmethod\n    def from_sa_model(cls, sa_model: ArtistSQLAlchemyModel) -&gt; Self:\n        return cls(\n            id=sa_model.id,\n            name=sa_model.name\n        )\n</code></pre>"},{"location":"getting-started/#framework-support","title":"Framework Support","text":"<p>SQLCrucible works with multiple Python model frameworks:</p> <ul> <li>Pydantic: Inherit from <code>SQLCrucibleBaseModel</code></li> <li>dataclasses: Use <code>@dataclass</code> with <code>SQLCrucibleEntity</code></li> <li>attrs: Use <code>@define</code> with <code>SQLCrucibleEntity</code></li> </ul> <pre><code>from dataclasses import dataclass, field\n\n@dataclass\nclass Artist(SQLCrucibleEntity):\n    __sqlalchemy_params__ = {\"__tablename__\": \"artist\"}\n    id: Annotated[UUID, mapped_column(primary_key=True)] = field(default_factory=uuid4)\n    name: str\n</code></pre>"},{"location":"getting-started/#caveats","title":"Caveats","text":"<ol> <li> <p>Cyclical references between model instances are not supported. Use <code>readonly_field</code> on one side to break the cycle.</p> </li> <li> <p>Pydantic and <code>readonly_field</code>: Either inherit from <code>SQLCrucibleBaseModel</code> (which includes the necessary config), or add <code>model_config = ConfigDict(ignored_types=(readonly_field,))</code> to your model.</p> </li> <li> <p>Forward references in relationships: Use lambdas to avoid circular import issues: <code>relationship(lambda: OtherEntity.__sqlalchemy_type__)</code>.</p> </li> <li> <p>Concrete table inheritance requires redefining ALL columns in each subclass.</p> </li> <li> <p><code>readonly_field</code> requires a backing SQLAlchemy model: Accessing a <code>readonly_field</code> on an entity not loaded via <code>from_sa_model()</code> raises <code>RuntimeError</code>.</p> </li> </ol>"},{"location":"guide/advanced/","title":"Advanced Usage","text":""},{"location":"guide/advanced/#customizing-the-generated-model","title":"Customizing the Generated Model","text":"<p>Override <code>__sqlalchemy_type__</code> with a <code>lazyproperty</code> to customize the generated SQLAlchemy model:</p> <pre><code>from sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlcrucible.utils.properties import lazyproperty\nfrom sqlcrucible import SQLCrucibleEntity\n\ndef user_sqlalchemy_type(cls: type[\"User\"]):\n    class CustomModel(cls.__sqlalchemy_automodel__):\n        @hybrid_property\n        def full_name(self):\n            return f\"{self.first_name} {self.last_name}\"\n\n    return CustomModel\n\nclass User(SQLCrucibleEntity):\n    __sqlalchemy_params__ = {\"__tablename__\": \"user\"}\n    first_name: str\n    last_name: str\n\n    __sqlalchemy_type__ = lazyproperty(user_sqlalchemy_type)\n</code></pre> <p>This allows you to add hybrid properties, custom methods, or any other SQLAlchemy-specific functionality to the generated model.</p>"},{"location":"guide/advanced/#reusing-existing-sqlalchemy-models","title":"Reusing Existing SQLAlchemy Models","text":"<p>You can attach a SQLCrucible entity to an existing SQLAlchemy model:</p> <pre><code>from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlcrucible import SQLCrucibleEntity\n\nclass Base(DeclarativeBase):\n    pass\n\n# Your existing SQLAlchemy model\nclass UserModel(Base):\n    __tablename__ = \"user\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column()\n    email: Mapped[str] = mapped_column()\n\n# Attach an entity to it\nclass User(SQLCrucibleEntity):\n    __sqlalchemy_type__ = UserModel\n\n    id: Annotated[int, mapped_column(primary_key=True)]\n    name: str\n    email: str\n</code></pre>"},{"location":"guide/advanced/#creating-views-with-subset-of-fields","title":"Creating \"Views\" with Subset of Fields","text":"<p>You can create multiple entity classes that map to the same SQLAlchemy model but expose different fields:</p> <pre><code># Full entity with all fields\nclass User(SQLCrucibleEntity):\n    __sqlalchemy_type__ = UserModel\n\n    id: Annotated[int, mapped_column(primary_key=True)]\n    name: str\n    email: str\n\n# Summary view with only some fields\nclass UserSummary(SQLCrucibleEntity):\n    __sqlalchemy_type__ = UserModel\n\n    id: Annotated[int, mapped_column(primary_key=True)]\n    name: str\n</code></pre>"},{"location":"guide/advanced/#type-stub-generation","title":"Type Stub Generation","text":"<p>SQLCrucible dynamically generates SQLAlchemy model classes at runtime. While this provides flexibility, Python's type system cannot represent these dynamically-created types \u2014 type checkers only see <code>type[Any]</code> for <code>__sqlalchemy_type__</code>, losing all column information.</p> <p>Type stubs (<code>.pyi</code> files) solve this by providing static type declarations. With generated stubs:</p> <ul> <li><code>Artist.__sqlalchemy_type__.name</code> is recognized as <code>InstrumentedAttribute[str]</code></li> <li>Invalid column access produces a type error</li> <li>IDE autocompletion works for column names</li> </ul>"},{"location":"guide/advanced/#generating-stubs","title":"Generating Stubs","text":"<pre><code># Generate stubs for a module\npython -m sqlcrucible.stubs myapp.models\n\n# Multiple modules\npython -m sqlcrucible.stubs myapp.models myapp.other_models\n\n# Custom output directory (default: stubs/)\npython -m sqlcrucible.stubs myapp.models --output typings/\n</code></pre> <p>Tip</p> <p>For projects with entities spread across many modules, create a single module that imports them all, then generate stubs from that.</p>"},{"location":"guide/advanced/#configuring-type-checkers","title":"Configuring Type Checkers","text":"PyrightMypyty <pre><code># pyproject.toml\n[tool.pyright]\nstubPath = \"stubs\"\n</code></pre> <pre><code># pyproject.toml\n[tool.mypy]\nmypy_path = \"stubs\"\n</code></pre> <pre><code># pyproject.toml\n[tool.ty.environment]\nextra-paths = [\"stubs\"]\n</code></pre>"},{"location":"guide/advanced/#keeping-stubs-updated","title":"Keeping Stubs Updated","text":"<p>Regenerate stubs whenever you add or modify entity fields. Consider adding stub generation to your CI process or using a pre-commit hook.</p>"},{"location":"guide/defining-entities/","title":"Defining Entities","text":""},{"location":"guide/defining-entities/#basic-entity-definition","title":"Basic Entity Definition","text":"<p>An entity is a class that serves as both a Pydantic model and a SQLAlchemy table definition. Use <code>mapped_column()</code> in <code>Annotated</code> to mark fields that should become database columns:</p> <pre><code>from typing import Annotated\nfrom uuid import UUID, uuid4\nfrom pydantic import Field\nfrom sqlalchemy.orm import mapped_column\nfrom sqlcrucible import SQLCrucibleBaseModel\n\nclass Artist(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__tablename__\": \"artist\"}\n\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    name: Annotated[str, mapped_column()]\n</code></pre> <p>Fields without <code>mapped_column()</code> are Pydantic-only and won't appear in the database.</p>"},{"location":"guide/defining-entities/#sharing-metadata-across-entities","title":"Sharing Metadata Across Entities","text":"<p>When defining multiple entities, use a custom base class to share a <code>MetaData</code> instance:</p> <pre><code>from sqlalchemy import MetaData\n\nclass BaseEntity(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__abstract__\": True, \"metadata\": MetaData()}\n\nclass Artist(BaseEntity):\n    __sqlalchemy_params__ = {\"__tablename__\": \"artist\"}\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    name: str\n\nclass Album(BaseEntity):\n    __sqlalchemy_params__ = {\"__tablename__\": \"album\"}\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    title: str\n</code></pre>"},{"location":"guide/defining-entities/#configuring-with-__sqlalchemy_params__","title":"Configuring with <code>__sqlalchemy_params__</code>","text":"<p>The <code>__sqlalchemy_params__</code> dictionary is placed directly into the generated SQLAlchemy model's class namespace. This means you can use it for any class-level attribute SQLAlchemy expects:</p> Key Purpose <code>__tablename__</code> The database table name <code>__table_args__</code> Table-level constraints, indexes, etc. <code>__mapper_args__</code> Mapper configuration (polymorphism, eager loading, etc.) <code>__abstract__</code> Mark as abstract base (no table created) <code>metadata</code> Custom <code>MetaData</code> instance"},{"location":"guide/defining-entities/#adding-sqlalchemy-only-columns","title":"Adding SQLAlchemy-Only Columns","text":"<p>You can use <code>__sqlalchemy_params__</code> to add columns that exist only on the SQLAlchemy model:</p> <pre><code>from sqlalchemy import Column, String, Index\nfrom sqlalchemy.orm import mapped_column\n\nclass User(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\n        \"__tablename__\": \"user\",\n        # Add a column only to the SQLAlchemy model\n        \"legacy_id\": Column(String(50), nullable=True),\n        # Add table-level constraints\n        \"__table_args__\": (\n            Index(\"ix_user_email\", \"email\"),\n        ),\n    }\n\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    email: str\n</code></pre> <p>The <code>legacy_id</code> column exists in the database and on <code>SAType[User]</code>, but isn't part of the <code>User</code> Pydantic model \u2014 useful for database-only fields, migration artifacts, or columns managed by triggers.</p>"},{"location":"guide/field-mapping/","title":"Field Mapping","text":""},{"location":"guide/field-mapping/#default-behavior","title":"Default Behavior","text":"<p>By default, all entity fields with a <code>mapped_column()</code> annotation are included in the generated SQLAlchemy model with the same name and type.</p>"},{"location":"guide/field-mapping/#excluding-fields-with-excludesafield","title":"Excluding Fields with <code>ExcludeSAField</code>","text":"<p>Use <code>ExcludeSAField</code> to exclude a field from the SQLAlchemy model while keeping it on the Pydantic entity:</p> <pre><code>from typing import Annotated\nfrom pydantic import Field\nfrom sqlcrucible import SQLCrucibleBaseModel\nfrom sqlcrucible.entity.annotations import ExcludeSAField\n\nclass Dog(Animal):\n    __sqlalchemy_params__ = {\"__mapper_args__\": {\"polymorphic_identity\": \"dog\"}}\n\n    bones_chewed: int | None = None\n    # Exclude 'type' from Dog's SQLAlchemy model \u2014 it's inherited from Animal\n    type: Annotated[str, ExcludeSAField()] = Field(default=\"dog\")\n</code></pre> <p>This is useful when:</p> <ul> <li>A child class overrides a parent field's default value (as with <code>type</code> above)</li> <li>You want a field on the Pydantic model that doesn't exist in the database</li> <li>You're using single-table inheritance and the column is already defined on the parent</li> </ul> <p>Note</p> <p>Fields marked with <code>ExcludeSAField()</code> must have a default value if you plan to use <code>from_sa_model()</code>, since there's no database column to populate them from.</p>"},{"location":"guide/field-mapping/#customizing-fields-with-sqlalchemyfield","title":"Customizing Fields with <code>SQLAlchemyField</code>","text":"<p><code>SQLAlchemyField</code> allows you to customize how entity fields map to SQLAlchemy columns:</p> Attribute Purpose Example <code>name</code> Rename the mapped column <code>SQLAlchemyField(name=\"db_column\")</code> <code>tp</code> Override the mapped type <code>SQLAlchemyField(tp=int)</code> <code>attr</code> Provide a Mapped[] attribute directly <code>SQLAlchemyField(attr=relationship(...))</code>"},{"location":"guide/field-mapping/#renaming-a-column","title":"Renaming a Column","text":"<pre><code>from typing import Annotated\nfrom uuid import UUID, uuid4\nfrom pydantic import Field\nfrom sqlalchemy.orm import mapped_column\nfrom sqlcrucible import SQLCrucibleBaseModel\nfrom sqlcrucible.entity.annotations import SQLAlchemyField\n\nclass User(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__tablename__\": \"user\"}\n\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    # Entity field 'email' maps to column 'email_address' in the database\n    email: Annotated[str, SQLAlchemyField(name=\"email_address\")]\n</code></pre>"},{"location":"guide/field-mapping/#overriding-the-column-type","title":"Overriding the Column Type","text":"<pre><code>from datetime import timedelta\nfrom typing import Annotated\nfrom sqlalchemy.orm import mapped_column\nfrom sqlcrucible import SQLCrucibleBaseModel\nfrom sqlcrucible.entity.annotations import SQLAlchemyField\n\nclass Task(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__tablename__\": \"task\"}\n\n    # Store timedelta as integer seconds in database\n    duration: Annotated[\n        timedelta,\n        mapped_column(),\n        SQLAlchemyField(tp=int),\n    ]\n</code></pre> <p>When overriding types, you'll typically also need to provide custom converters. See Type Conversion for details.</p>"},{"location":"guide/inheritance/","title":"Inheritance","text":"<p>SQLCrucible supports all three SQLAlchemy inheritance patterns. Each uses <code>__sqlalchemy_params__</code> with <code>__mapper_args__</code> to configure polymorphism.</p>"},{"location":"guide/inheritance/#single-table-inheritance","title":"Single Table Inheritance","text":"<p>All subclasses share one table with a discriminator column:</p> <pre><code>from typing import Annotated\nfrom uuid import UUID, uuid4\nfrom pydantic import Field\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import mapped_column\nfrom sqlcrucible import SQLCrucibleBaseModel\nfrom sqlcrucible.entity.annotations import ExcludeSAField\n\nclass Animal(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\n        \"__tablename__\": \"animal\",\n        \"__mapper_args__\": {\"polymorphic_on\": \"type\", \"polymorphic_identity\": \"animal\"},\n    }\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    type: Annotated[str, mapped_column(String(50))]\n    name: str\n\nclass Dog(Animal):\n    __sqlalchemy_params__ = {\"__mapper_args__\": {\"polymorphic_identity\": \"dog\"}}\n    bones_chewed: Annotated[int | None, mapped_column(nullable=True)] = None\n    # Override default but exclude from SA model (column exists on parent)\n    type: Annotated[str, ExcludeSAField()] = Field(default=\"dog\")\n\nclass Cat(Animal):\n    __sqlalchemy_params__ = {\"__mapper_args__\": {\"polymorphic_identity\": \"cat\"}}\n    hours_napped: Annotated[int | None, mapped_column(nullable=True)] = None\n    type: Annotated[str, ExcludeSAField()] = Field(default=\"cat\")\n</code></pre>"},{"location":"guide/inheritance/#joined-table-inheritance","title":"Joined Table Inheritance","text":"<p>Each subclass has its own table with a foreign key to the parent:</p> <pre><code>from typing import Annotated\nfrom uuid import UUID, uuid4\nfrom pydantic import Field\nfrom sqlalchemy import ForeignKey, String\nfrom sqlalchemy.orm import mapped_column\nfrom sqlcrucible import SQLCrucibleBaseModel\nfrom sqlcrucible.entity.annotations import ExcludeSAField\n\nclass Animal(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\n        \"__tablename__\": \"animal\",\n        \"__mapper_args__\": {\"polymorphic_on\": \"type\", \"polymorphic_identity\": \"animal\"},\n    }\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    type: Annotated[str, mapped_column(String(50))]\n    name: str\n\nclass Dog(Animal):\n    __sqlalchemy_params__ = {\n        \"__tablename__\": \"dog\",\n        \"__mapper_args__\": {\"polymorphic_identity\": \"dog\"},\n    }\n    id: Annotated[UUID, mapped_column(ForeignKey(\"animal.id\"), primary_key=True)] = Field(default_factory=uuid4)\n    bones_chewed: int | None = None\n    type: Annotated[str, ExcludeSAField()] = Field(default=\"dog\")\n</code></pre>"},{"location":"guide/inheritance/#concrete-table-inheritance","title":"Concrete Table Inheritance","text":"<p>Each subclass is a completely independent table:</p> <pre><code>from typing import Annotated\nfrom uuid import UUID, uuid4\nfrom pydantic import Field\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import mapped_column\nfrom sqlcrucible import SQLCrucibleBaseModel\n\nclass Animal(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\n        \"__abstract__\": True,\n        \"__mapper_args__\": {\"polymorphic_on\": \"type\"},\n    }\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    type: Annotated[str, mapped_column(String(50))]\n    name: str\n\nclass Dog(Animal):\n    __sqlalchemy_params__ = {\n        \"__tablename__\": \"dog\",\n        \"__mapper_args__\": {\"polymorphic_identity\": \"dog\", \"concrete\": True},\n    }\n    # Must redefine ALL columns for concrete table inheritance\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    type: Annotated[str, mapped_column(String(50))] = Field(default=\"dog\")\n    name: str\n    bones_chewed: int | None = None\n</code></pre> <p>Warning</p> <p>Concrete table inheritance requires redefining ALL columns in each subclass.</p>"},{"location":"guide/inheritance/#polymorphic-round-trip","title":"Polymorphic Round-Trip","text":"<p>When using inheritance, <code>from_sa_model()</code> automatically returns the correct subclass:</p> <pre><code>dog_sa = Dog.__sqlalchemy_type__(id=uuid4(), name=\"Fido\", type=\"dog\", bones_chewed=42)\n\n# Load via the base class \u2014 returns Dog, not Animal\nanimal = Animal.from_sa_model(dog_sa)\nassert isinstance(animal, Dog)\nassert animal.bones_chewed == 42\n</code></pre> <p>This works because SQLCrucible inspects the polymorphic identity to determine which entity class to instantiate.</p>"},{"location":"guide/relationships/","title":"Relationships","text":""},{"location":"guide/relationships/#defining-relationships","title":"Defining Relationships","text":"<p>Use <code>readonly_field</code> to define relationship fields that are loaded from the SQLAlchemy model but not part of the entity's constructor:</p> <pre><code>from typing import Annotated\nfrom uuid import UUID, uuid4\nfrom pydantic import Field\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import mapped_column, relationship\nfrom sqlcrucible import SQLCrucibleBaseModel\nfrom sqlcrucible.entity.fields import readonly_field\nfrom sqlcrucible.entity.annotations import SQLAlchemyField\n\nclass Artist(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__tablename__\": \"artist\"}\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    name: str\n\nclass Track(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__tablename__\": \"track\"}\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    name: str\n    artist_id: Annotated[UUID, mapped_column(ForeignKey(\"artist.id\"))]\n\n    # Read-only relationship field\n    artist = readonly_field(\n        Artist,\n        SQLAlchemyField(\n            name=\"artist\",\n            attr=relationship(lambda: Artist.__sqlalchemy_type__),\n        ),\n    )\n</code></pre> <p>Tip</p> <p>Use a lambda for the relationship target to avoid circular import issues.</p>"},{"location":"guide/relationships/#how-readonly_field-works","title":"How <code>readonly_field</code> Works","text":"<p>The <code>readonly_field</code> descriptor:</p> <ol> <li>Excludes the field from Pydantic validation \u2014 it won't appear in the model's <code>__init__</code></li> <li>Defines a SQLAlchemy relationship on the generated model</li> <li>Loads the related entity when accessed via <code>from_sa_model()</code></li> </ol> <p>When you query a <code>Track</code> and call <code>from_sa_model()</code>, the <code>artist</code> relationship is automatically converted to an <code>Artist</code> entity.</p>"},{"location":"guide/relationships/#important-notes","title":"Important Notes","text":"<ul> <li> <p>Cyclical references are not supported. If <code>Artist</code> has a <code>tracks</code> relationship and <code>Track</code> has an <code>artist</code> relationship, use <code>readonly_field</code> on at least one side to break the cycle.</p> </li> <li> <p>Pydantic compatibility: Either inherit from <code>SQLCrucibleBaseModel</code> (which includes the necessary config), or add <code>model_config = ConfigDict(ignored_types=(readonly_field,))</code> to your model.</p> </li> <li> <p>Accessing without a backing model: Accessing a <code>readonly_field</code> on an entity not loaded via <code>from_sa_model()</code> raises <code>RuntimeError</code>.</p> </li> </ul>"},{"location":"guide/relationships/#example-one-to-many-relationship","title":"Example: One-to-Many Relationship","text":"<pre><code>class Artist(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__tablename__\": \"artist\"}\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    name: str\n\n    # One-to-many: artist has many tracks\n    tracks = readonly_field(\n        list[\"Track\"],\n        SQLAlchemyField(\n            name=\"tracks\",\n            attr=relationship(lambda: Track.__sqlalchemy_type__, back_populates=\"artist\"),\n        ),\n    )\n\nclass Track(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__tablename__\": \"track\"}\n    id: Annotated[UUID, mapped_column(primary_key=True)] = Field(default_factory=uuid4)\n    name: str\n    artist_id: Annotated[UUID, mapped_column(ForeignKey(\"artist.id\"))]\n\n    # Many-to-one: track belongs to artist\n    artist = readonly_field(\n        Artist,\n        SQLAlchemyField(\n            name=\"artist\",\n            attr=relationship(lambda: Artist.__sqlalchemy_type__, back_populates=\"tracks\"),\n        ),\n    )\n</code></pre>"},{"location":"guide/type-conversion/","title":"Type Conversion","text":""},{"location":"guide/type-conversion/#custom-type-converters","title":"Custom Type Converters","text":"<p>Use <code>ConvertToSAWith</code> and <code>ConvertFromSAWith</code> to customize conversion between your entity and the SQLAlchemy model:</p> <pre><code>from datetime import timedelta\nfrom typing import Annotated\nfrom sqlalchemy.orm import mapped_column\nfrom sqlcrucible import SQLCrucibleBaseModel\nfrom sqlcrucible.entity.annotations import ConvertFromSAWith, ConvertToSAWith, SQLAlchemyField\n\nclass Track(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__tablename__\": \"track\"}\n\n    # Store as integer seconds in database, use timedelta in Python\n    length: Annotated[\n        timedelta,\n        mapped_column(),\n        SQLAlchemyField(name=\"length_seconds\", tp=int),\n        ConvertToSAWith(lambda td: td.total_seconds()),\n        ConvertFromSAWith(lambda s: timedelta(seconds=s)),\n    ]\n</code></pre>"},{"location":"guide/type-conversion/#how-the-conversion-system-works","title":"How the Conversion System Works","text":"<p>When converting between Pydantic and SQLAlchemy models, SQLCrucible uses a registry of type converters. Understanding how this works helps when dealing with complex nested types.</p>"},{"location":"guide/type-conversion/#built-in-converters","title":"Built-in Converters","text":"<p>The converter registry resolves conversions by finding a converter that matches the source and target types. Built-in converters handle:</p> <ul> <li>Primitive types (<code>str</code>, <code>int</code>, <code>bool</code>, etc.) \u2014 passed through unchanged</li> <li>Sequences (<code>list</code>, <code>tuple</code>, <code>set</code>, <code>frozenset</code>) \u2014 element-wise conversion with container duplication</li> <li>Dicts and TypedDicts \u2014 key-by-key value conversion</li> <li>Unions \u2014 finds the best matching branch based on type compatibility</li> <li>Literals \u2014 validates values against allowed literal values</li> </ul>"},{"location":"guide/type-conversion/#collection-duplication","title":"Collection Duplication","text":"<p>Collections are always duplicated during conversion rather than passed through by reference. This prevents SQLAlchemy operations from affecting Pydantic model state and vice versa:</p> <pre><code>class Artist(SQLCrucibleBaseModel):\n    __sqlalchemy_params__ = {\"__tablename__\": \"artist\"}\n    tags: list[str]  # This list is copied, not shared\n\nartist = Artist(tags=[\"rock\", \"blues\"])\nsa_artist = artist.to_sa_model()\n\n# Modifying the SQLAlchemy model's list doesn't affect the original\nsa_artist.tags.append(\"jazz\")\nassert \"jazz\" not in artist.tags  # True \u2014 they're separate lists\n</code></pre> <p>If you need strict passthrough (same object reference), register a custom no-op converter for your specific type using <code>ConvertToSAWith</code> and <code>ConvertFromSAWith</code> with identity functions.</p>"},{"location":"guide/type-conversion/#dict-and-typeddict-conversion","title":"Dict and TypedDict Conversion","text":"<p>Dict conversion resolves value converters for each field. There are some important behaviours to be aware of:</p>"},{"location":"guide/type-conversion/#unparameterized-dicts","title":"Unparameterized Dicts","text":"<p>An unparameterized <code>dict</code> has value type <code>Any</code>. When converting to a <code>TypedDict</code> with typed fields, the converter cannot prove that <code>Any</code> values are compatible with specific field types like nested <code>TypedDict</code>s:</p> <pre><code>from typing import TypedDict, Any\n\nclass PersonDict(TypedDict):\n    name: str\n    age: int\n\nclass NestedDict(TypedDict):\n    person: PersonDict  # Nested TypedDict\n    active: bool\n\n# This works \u2014 dict[str, Any] values convert to str/int via no-op\nconverter = registry.resolve(dict[str, Any], PersonDict)  # OK\n\n# This returns None \u2014 can't prove Any -&gt; PersonDict is valid\nconverter = registry.resolve(dict, NestedDict)  # None\n</code></pre> <p>Recommendation</p> <p>Use parameterized dict types (<code>dict[str, Any]</code>, <code>dict[str, int]</code>) when you need predictable conversion behaviour with nested structures.</p>"},{"location":"guide/type-conversion/#required-field-validation","title":"Required Field Validation","text":"<p>If a target <code>TypedDict</code> has required fields that aren't present in the source dict, conversion raises <code>TypeError</code>.</p>"},{"location":"reference/api/","title":"API Reference","text":""},{"location":"reference/api/#core-classes","title":"Core Classes","text":""},{"location":"reference/api/#sqlcruciblebasemodel","title":"SQLCrucibleBaseModel","text":""},{"location":"reference/api/#sqlcrucible.SQLCrucibleBaseModel","title":"<code>sqlcrucible.SQLCrucibleBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>SQLCrucibleEntity</code></p>"},{"location":"reference/api/#sqlcrucible.SQLCrucibleBaseModel.__sqlalchemy_params__","title":"<code>__sqlalchemy_params__ = {'__abstract__': True}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/api/#sqlcrucibleentity","title":"SQLCrucibleEntity","text":""},{"location":"reference/api/#sqlcrucible.SQLCrucibleEntity","title":"<code>sqlcrucible.SQLCrucibleEntity</code>","text":"<p>Base class for entities that auto-generate SQLAlchemy models.</p> <p>Subclasses define their schema using type annotations with SQLAlchemy markers (mapped_column, relationship, etc.). The SQLAlchemy model is automatically generated and accessible via sqlalchemy_type.</p> Class Attributes <p>sqlalchemy_base: Optional custom DeclarativeBase for the SA model. sqlalchemy_params: SQLAlchemy configuration (tablename, etc.). converter_registry: Converter registry for field type conversion. sqlalchemy_automodel: The auto-generated SQLAlchemy model class. sqlalchemy_type: The SQLAlchemy model class to use (defaults to sqlalchemy_automodel).</p> Example <pre><code>@dataclass\nclass User(SQLCrucibleEntity):\n    __sqlalchemy_params__ = {\"__tablename__\": \"users\"}\n\n    id: Annotated[int, mapped_column(Integer, primary_key=True)]\n    name: Annotated[str, mapped_column(String(50))]\n    email: Annotated[str | None, mapped_column(String(100))]\n\n\n# Use the entity\nuser = User(id=1, name=\"Alice\", email=\"alice@example.com\")\nsa_model = user.to_sa_model()  # Convert to SQLAlchemy\n\n# Convert back\nuser2 = User.from_sa_model(sa_model)\n</code></pre>"},{"location":"reference/api/#sqlcrucible.SQLCrucibleEntity.__sqlalchemy_type__","title":"<code>__sqlalchemy_type__ = SQLAlchemyBase</code>  <code>class-attribute</code>","text":""},{"location":"reference/api/#sqlcrucible.SQLCrucibleEntity.__sqlalchemy_params__","title":"<code>__sqlalchemy_params__ = {}</code>  <code>class-attribute</code>","text":""},{"location":"reference/api/#sqlcrucible.SQLCrucibleEntity.to_sa_model","title":"<code>to_sa_model()</code>","text":"<p>Convert this entity to a SQLAlchemy model instance.</p> <p>Creates a new SQLAlchemy model populated with data from this entity, applying any configured type converters for each field.</p> <p>Returns:</p> Type Description <code>Any</code> <p>A SQLAlchemy model instance ready to be added to a session.</p>"},{"location":"reference/api/#sqlcrucible.SQLCrucibleEntity.from_sa_model","title":"<code>from_sa_model(sa_model)</code>  <code>classmethod</code>","text":"<p>Create an entity instance from a SQLAlchemy model.</p> <p>This method converts a SQLAlchemy model instance into the corresponding entity class. For polymorphic models, it automatically selects the most specific entity subclass that matches the model type.</p> <p>Parameters:</p> Name Type Description Default <code>sa_model</code> <code>Any</code> <p>A SQLAlchemy model instance to convert.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An entity instance populated with data from the SQLAlchemy model.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If sa_model is None.</p> <code>ValueError</code> <p>If sa_model is not compatible with this entity's SQLAlchemy type.</p>"},{"location":"reference/api/#satype","title":"SAType","text":""},{"location":"reference/api/#sqlcrucible.SAType","title":"<code>sqlcrucible.SAType</code>","text":"<p>Utility to access an entity's SQLAlchemy type.</p> <p>Provides a cleaner syntax for accessing an entity's SQLAlchemy type:</p> <pre><code># Instead of:\nselect(Track.__sqlalchemy_type__).where(Track.__sqlalchemy_type__.length_seconds &gt; 180)\n\n# Write:\nselect(SAType[Track]).where(SAType[Track].length_seconds &gt; 180)\n</code></pre> <p>With generated stubs, type checkers know the exact return type and can provide autocompletion for column names.</p>"},{"location":"reference/api/#annotations","title":"Annotations","text":""},{"location":"reference/api/#sqlalchemyfield","title":"SQLAlchemyField","text":""},{"location":"reference/api/#sqlcrucible.entity.annotations.SQLAlchemyField","title":"<code>sqlcrucible.entity.annotations.SQLAlchemyField</code>  <code>dataclass</code>","text":"<p>Configuration for mapping an entity field to SQLAlchemy.</p> <p>This annotation can be used to customize how entity fields are mapped to SQLAlchemy columns or relationships.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>The name to use for the mapped attribute (defaults to field name)</p> <code>attr</code> <code>Mapped[Any] | None</code> <p>A Mapped[] attribute to use directly</p> <code>tp</code> <code>Any | None</code> <p>The type to use for the mapped attribute</p>"},{"location":"reference/api/#sqlcrucible.entity.annotations.SQLAlchemyField.merge_all","title":"<code>merge_all(*fields)</code>  <code>classmethod</code>","text":"<p>Merge multiple SQLAlchemyField annotations, with later values taking precedence.</p>"},{"location":"reference/api/#excludesafield","title":"ExcludeSAField","text":""},{"location":"reference/api/#sqlcrucible.entity.annotations.ExcludeSAField","title":"<code>sqlcrucible.entity.annotations.ExcludeSAField</code>  <code>dataclass</code>","text":""},{"location":"reference/api/#converttosawith","title":"ConvertToSAWith","text":""},{"location":"reference/api/#sqlcrucible.entity.annotations.ConvertToSAWith","title":"<code>sqlcrucible.entity.annotations.ConvertToSAWith</code>  <code>dataclass</code>","text":"<p>Annotation specifying custom converter from entity to SQLAlchemy.</p> <p>Use this annotation to provide a custom conversion function when saving entity values into SQLAlchemy models.</p> Example <pre><code>from typing import Annotated\n\n\nclass MyEntity(SQLCrucibleEntity):\n    created_at: Annotated[\n        datetime, mapped_column(), ConvertToSAWith(lambda dt: dt.astimezone(timezone.utc))\n    ]\n</code></pre>"},{"location":"reference/api/#sqlcrucible.entity.annotations.ConvertToSAWith.converter","title":"<code>converter</code>  <code>property</code>","text":"<p>Get the Converter instance for this function.</p>"},{"location":"reference/api/#convertfromsawith","title":"ConvertFromSAWith","text":""},{"location":"reference/api/#sqlcrucible.entity.annotations.ConvertFromSAWith","title":"<code>sqlcrucible.entity.annotations.ConvertFromSAWith</code>  <code>dataclass</code>","text":"<p>Annotation specifying custom converter from SQLAlchemy to entity.</p> <p>Use this annotation to provide a custom conversion function when loading values from SQLAlchemy models into entity instances.</p> Example <pre><code>from typing import Annotated\n\n\nclass MyEntity(SQLCrucibleEntity):\n    created_at: Annotated[\n        datetime, mapped_column(), ConvertFromSAWith(lambda dt: dt.astimezone(timezone.utc))\n    ]\n</code></pre>"},{"location":"reference/api/#sqlcrucible.entity.annotations.ConvertFromSAWith.converter","title":"<code>converter</code>  <code>property</code>","text":"<p>Get the Converter instance for this function.</p>"},{"location":"reference/api/#fields","title":"Fields","text":""},{"location":"reference/api/#readonly_field","title":"readonly_field","text":""},{"location":"reference/api/#sqlcrucible.entity.fields.readonly_field","title":"<code>sqlcrucible.entity.fields.readonly_field</code>","text":"<p>Descriptor for read-only fields populated from SQLAlchemy relationships.</p> <p>This descriptor allows defining fields that are loaded from SQLAlchemy relationships but not included in the entity's constructor. The value is lazily loaded from the SQLAlchemy model when accessed.</p> Example <pre><code>@dataclass\nclass Track(SQLCrucibleEntity):\n    __sqlalchemy_params__ = {\"__tablename__\": \"track\"}\n\n    id: Annotated[int, mapped_column(primary_key=True)]\n    title: Annotated[str, mapped_column()]\n    artist_id: Annotated[int, mapped_column(ForeignKey(\"artist.id\"))]\n\n    # Read-only field loaded from relationship\n    artist = readonly_field(\n        Artist, SQLAlchemyField(attr=relationship(Artist, back_populates=\"tracks\"))\n    )\n</code></pre> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>_T</code> <p>The type of the field value</p> required <code>_O</code> <p>The type of the owning entity class</p> required"},{"location":"reference/api/#sqlcrucible.entity.fields.readonly_field.sa_field_info","title":"<code>sa_field_info</code>  <code>property</code>","text":"<p>Get the SQLAlchemy field definition for this descriptor.</p> <p>This property resolves any forward references in the type, which requires all referenced classes to be defined. It's safe to call after class creation is complete.</p> <p>Returns:</p> Type Description <code>SQLAlchemyFieldDefinition</code> <p>The field definition with resolved types</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If accessed before the descriptor is assigned to a class</p>"},{"location":"reference/api/#sqlcrucible.entity.fields.readonly_field.__init__","title":"<code>__init__(tp, sa_field=None)</code>","text":"<p>Initialize a readonly field descriptor.</p> <p>Parameters:</p> Name Type Description Default <code>tp</code> <code>Any</code> <p>The type of the field value (can be a type, string forward ref, or parameterized type)</p> required <code>sa_field</code> <code>SQLAlchemyField | None</code> <p>Optional SQLAlchemyField configuration for the mapped attribute</p> <code>None</code>"},{"location":"reference/api/#sqlcrucible.entity.fields.readonly_field.__set_name__","title":"<code>__set_name__(owner, name)</code>","text":"<p>Called when the descriptor is assigned to a class attribute.</p> <p>Registers the field definition with the entity class. Forward references in the type are resolved lazily when the field definition is actually accessed, not during class creation.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>type[_O]</code> <p>The entity class owning this field</p> required <code>name</code> <code>str</code> <p>The name of the field in the entity class</p> required"},{"location":"reference/api/#sqlcrucible.entity.fields.readonly_field.__get__","title":"<code>__get__(instance, owner)</code>","text":"<pre><code>__get__(instance: None, owner: type[_O]) -&gt; Self\n</code></pre><pre><code>__get__(instance: _O, owner: type[_O]) -&gt; _T\n</code></pre> <p>Get the field value from an entity instance.</p> <p>When accessed on the class, returns the descriptor itself. When accessed on an instance, loads the value from the SQLAlchemy model.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>_O | None</code> <p>The entity instance (or None if accessed on class)</p> required <code>owner</code> <code>type[_O]</code> <p>The entity class</p> required <p>Returns:</p> Type Description <code>_T | Self</code> <p>The descriptor (if accessed on class) or the field value (if on instance)</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the entity instance is not backed by a SQLAlchemy model</p>"},{"location":"reference/api/#utilities","title":"Utilities","text":""},{"location":"reference/api/#lazyproperty","title":"lazyproperty","text":""},{"location":"reference/api/#sqlcrucible.utils.properties.lazyproperty","title":"<code>sqlcrucible.utils.properties.lazyproperty(func)</code>","text":""}]}